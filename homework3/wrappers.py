###############################################################################
# DO NOT EDIT THIS FILE! (Any changes will be overwritten.)
#
# Read the documentation here to see how to call each function and what kind of
# output to expect.
#
###############################################################################

import ctypes
import numpy
import os

from ctypes import (
    c_void_p,
    c_int,
    c_double,
)

# try to import the library
try:
    path_to_library = os.path.join('lib','libhomework3.so')
    homework3library = ctypes.cdll.LoadLibrary(path_to_library)
except OSError:
    raise OSError("You need to compile your homework library using 'make'.")


def trapz_serial(fvals, x):
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.trapz_serial
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int]
        output = f(fvals.ctypes.data, x.ctypes.data, N)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def trapz_parallel(fvals, x, num_threads=4):
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.trapz_parallel
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int, c_int]
        output = f(fvals.ctypes.data, x.ctypes.data, N, num_threads)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def time_trapz_parallel(fvals, x, num_threads=4):
    r""" Returns the amount of time it takes to perform parallel trapezoidal rule.

    Optionally specify number of threads to use in omp as well as the number of
    times to repeat this timing in order to computer averages.

    Parameters
    ----------
    fvals : Numpy array
        The function values along the `x` range.
    x : Numpy array
        The x-points at which the function is evaluated.
    num_threads : int
        (Default: 4) The number of threads to spawn when computing the integral.
    repeat : int
        (Default: 5) Number of times to compute the integral. Time returned is
        the equal to the average across these runs.

    """
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.time_trapz_parallel
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int, c_int]
        output = f(fvals.ctypes.data, x.ctypes.data, N, num_threads)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def simps_serial(fvals, x):
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.simps_serial
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int]
        output = f(fvals.ctypes.data, x.ctypes.data, N)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def simps_parallel(fvals, x, num_threads=4):
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.simps_parallel
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int, c_int]
        output = f(fvals.ctypes.data, x.ctypes.data, N, num_threads)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def time_simps_parallel(fvals, x, num_threads=4, repeat=5):
    r""" Returns the amount of time it takes to perform parallel trapezoidal rule.

    Optionally specify number of threads to use in omp as well as the number of
    times to repeat this timing in order to computer averages.

    Parameters
    ----------
    fvals : Numpy array
        The function values along the `x` range.
    x : Numpy array
        The x-points at which the function is evaluated.
    num_threads : int
        (Default: 4) The number of threads to spawn when computing the integral.
    repeat : int
        (Default: 5) Number of times to compute the integral. Time returned is
        the equal to the average across these runs.

    """
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.time_simps_parallel
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int, c_int, c_int]

        # run `number` times and compute the average
        output = f(fvals.ctypes.data, x.ctypes.data, N, num_threads, repeat)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def simps_parallel_chunked(fvals, x, num_threads=4, chunk_size=1):
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.simps_parallel_chunked
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int, c_int, c_int]
        output = f(fvals.ctypes.data, x.ctypes.data, N, num_threads, chunk_size)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output

def time_simps_parallel_chunked(fvals, x, num_threads=4, chunk_size=1, repeat=5):
    r""" Returns the amount of time it takes to perform parallel trapezoidal rule.

    Optionally specify number of threads to use in omp as well as the number of
    times to repeat this timing in order to computer averages.

    Parameters
    ----------
    fvals : Numpy array
        The function values along the `x` range.
    x : Numpy array
        The x-points at which the function is evaluated.
    chunk_size : int
        (Default: 1) Specify the chunk size to use in the parallel for loop.
    num_threads : int
        (Default: 4) The number of threads to spawn when computing the integral.
    repeat : int
        (Default: 5) Number of times to compute the integral. Time returned is
        the equal to the average across these runs.

    """
    # check dimensions
    N = len(fvals)
    if N != len(x):
        raise ValueError('fvals and x must have same length.')

    # ensure contiguous data
    fvals = numpy.ascontiguousarray(numpy.array(fvals, dtype=numpy.double))
    x = numpy.ascontiguousarray(numpy.array(x, dtype=numpy.double))

    # set function types and evaluate
    try:
        f = homework3library.time_simps_parallel_chunked
        f.restype = c_double
        f.argtypes = [c_void_p, c_void_p, c_int, c_int, c_int, c_int]

        # run `number` times and compute the average
        output = f(fvals.ctypes.data, x.ctypes.data, N, num_threads,
                   chunk_size, repeat)
    except AttributeError:
        raise AttributeError("Something wrong happened when calling the C "
                             "library function.")
    return output
